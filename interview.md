#### 1. Golang 中除了加 Mutex 锁以外还有哪些方式安全读写共享变量？

- Golang 中 Goroutine 可以通过 Channel 进行安全读写共享变量。

#### 2. 无缓冲 Chan 的发送和接收是否同步？

- ch := make(chan int) 无缓冲 Channel 由于没有缓冲，发送和接收需要同步
- ch := make(chan int, 2) 有缓冲 Channel 不要求发送和接收同步
- channel 无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据
- channel 有缓冲时，当缓冲满时发送数据，当缓冲空时接收数据

#### 3. Go 语言的并发机制以及它所使用的 CSP 并发模型

- CSP 模型：不同于传统的多线程通过共享内存来通信，它是“以通信的方式来共享内存”。用于描述两个并发的独立实体通过共享通讯 Channel （管道）进行通信的并发模型。CSP 中 channel 是第一类对象，它不关注发送消息的实体，而关注发送消息时使用的 channel.
- Golang 中 channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式，一个实体将消息发送到 channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，实现实体间的解耦。channel 是同步的一个消息被发送到 channel 中，最终一定要被另外的实体消费掉。实现原理上类似于一个阻塞的消息队列。
- Goroutine 的底层是使用协程 (Coroutine) 实现并发，coroutine 是运行在用户态的用户线程，类似于 greenthread, go 底层使用它的原因：
  - 用户空间， 避免内核态和用户态的切换导致的成本；
  - 可以由语言和框架层进行调度；
  - 更小的栈空间，允许创建大量的实体。
- Goroutine 内部有三个对象：P (processor) 上下文、M (work thread) 工作线程、G (goroutine). 正常情况下，一个 cpu 对象启动一个工作线程对象，线程去检查并执行 goroutine 对象，碰到 goroutine 对象阻塞时，会启动一个新的工作线程，以充分利用 cpu 资源。所以线程对象会比处理器对象多得多。
- G (Goroutine): 协程，为用户级的轻量级线程，每个 Goroutine 对象中的 sched 保存着其上下文信息
- M (Machine): 对内核级线程的封装，数量对应真实的 CPU 数
- P (Processor): G 和 M 的调度对象，用来调度 G 和 M 之间的关联关系

#### 4. Golang 中常用的并发模型

- 通过 Channel 通知实现并发控制
- 通过 sync 包中的 WaitGroup 实现并发控制：WaitGroup 会等待收集的所有 Goroutine 任务全部完成，三个主要方法：
  - Add: 可以添加或减少 goroutine 的数量
  - Done: 相当于 Add(-1)
  - Wait: 执行后会阻塞主线程，直到 WaitGroup 里的值减至 0
  - A WaitGroup must not be copied after first use.
- 通过 Context 上下文实现并发控制
  - Context：适用于复杂多变的网络并发场景。它是 goroutine 的上下文，包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常 Go 会将这些封装在一个 Context 里，再将它传给要执行的 goroutine. 主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。
- Context 对象是线程安全的，把一个 Context 对象传递给任意个数的 goroutine, 对它执行取消操作时，所有 goroutine 都会接收到取消信号。

#### 5. Json 标准库对 nil slice 和 空 slice 处理是否一致？

- 不一致，nil slice 和 empty slice 是不同的
- `var slice []int`, 只声明了 slice, 没有给实例化对象，slice 值为 nil, 可以用于需要返回 slice 的函数，当函数出现异常时，保证函数会有 nil 的返回值
- `slice := make([]int, 0)` 或 `slice := []int{}`, empty slice 指 slice 不为 nil，但没有值，底层空间是空的

#### 6. 协程、线程、进程的区别

- 进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单元，每个进程都有自己的独立内存空间，上下文进程间的切换（栈、寄存器、虚拟内存、文件句柄）开销比较大，但相对比较稳定安全
- 线程：线程是进程的一个实体，是 CPU 调度和分派的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（程序计数器，一组寄存器和栈），但它可与同属一个进程的其他线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据
- 协程：协程是一种用户态的轻量级线程，调度完全由用户控制，拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，切回来时，恢复先前保存的。直接操作栈基本没有内核切换的开销，可以不加锁的访问全局变量，上下文切换非常快

#### 7. 互斥锁，读写锁，死锁问题如何解决

- 互斥锁：互斥锁就是互斥变量 mutex，用来锁住临界区。条件锁就是条件变量，当进程的某些资源不满足要求时进入睡眠，当资源分配到时，条件锁打开，进程继续运行；读写锁，用于缓冲区等临界资源能互斥访问
- 读写锁：通常有些公共数据修改的机会很少，但读的机会很多，并且在读的过程中伴随着查找，给这种代码加锁会降低程序效率，读写锁可以解决这种问题。写独占，读共享，写锁优先级高。
- 死锁：若同一个线程先后两次调用 lock，在第二次调用时，由于锁被占用，该线程会被挂起等待其他线程释放锁，但锁是被自己占用着，该线程又被挂起没有机会释放锁，因此就永远处于挂起等待状态，即死锁 (Deadlock)。另一种情况：若线程 A 获得锁 1，线程 B 获得锁 2，这时线程 A 调用 lock 试图获得锁 2，结果需要挂起等待线程 B 释放锁 2，而线程 B 也调用 lock 试图获得锁 1，结果需要挂起等待线程 A 释放锁 1，于是线程 A，B 永远处于挂起状态了
- 死锁产生的四个必要条件：只要系统发生死锁，这些条件必然成立；只要以下条件之一不满足，就不会发生死锁
  - 互斥条件：一个资源每次只能被一个进程使用
  - 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
  - 不可剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
  - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
- 预防死锁：严重损害系统性能
  - 可以把资源一次性分配（破坏请求与保持条件）
  - 剥夺资源：当某进程资源未满足时，释放已占有的资源（破坏不可剥夺条件）
  - 资源有序分配法：系统给每类资源赋予一个编号，每个进程按编号递增的顺序请求资源，释放则相反（破坏循环等待条件）
- 避免死锁：允许进程动态地申请资源。系统在资源分配之前预先计算资源分配的安全性，若分配不会导致系统进入不安全状态，则将资源分配给进程，否则进程等待。最具有代表性的避免死锁算法是银行家算法。
- 检测死锁：首先为每个进程和每个资源指定一个唯一的号码，然后建立资源分配表和进程等待表
- 解除死锁：当发现有进程死锁后，立即把它从死锁状态解脱出来
- 剥夺资源：从其他进程剥夺足够数量的资源给死锁进程，以解除死锁状态
- 撤销进程：撤销死锁进程或撤销代价最小的进程，直到有足够的资源可用。代价指优先级、运行代价、进程的重要性和价值

#### 8. Golang 的内存模型，为什么小对象多了会造成 gc 压力？

- 通常小对象过多会导致 GC 三色法消耗过多的 GPU. 优化思路是，减少对象分配。

#### 9. Data Race 问题如何解决，能否不加锁解决？

- 同步访问共享数据是处理数据竞争的一种有效方法。Golang 的竞争检测机制，可以使用 `go run --race` 或 `go build --race` 来进行静态检测。其内部实现是，开启多个协程执行同一命令，并且记录下每个变量的状态。
- 竞争检测器基于 C/C++ 的 `ThreadSanitizer` 运行时库，该库在 Google 内部代码基地和 Chromium 找到许多错误。集成到 Go 后，它已经在标准库中检测出 42 个竞争条件。
- 解决数据竞争问题，可以使用互斥锁 `sync.Mutex`, 也可以使用管道。使用管道的效率要比互斥锁高。

#### 10. 什么是 Channel, 为何它可以做到线程安全？

- Channel 可以理解成一个先进先出的队列，通过管道进行通信。
- 在 Golang 中，发送一个数据到 Channel 和从 Channel 接收一个数据都是原子性的。Go 的设计思想是：不要通过共享内存来通信，而要通过通信来共享内存。前者是传统的加锁，后者是 Channel. 
- 设计 Channel 的主要目的是在多任务间传递数据的，当然安全。

#### 11. Epoll 原理

- Epoll 是一种 I/O 多路复用技术，可以非常高效地处理数以万计的 Socket 句柄，比 Select 和 Poll 效率高很多。
- C 库封装的 3 个 epoll 系统调用：
  - ```c
    int epoll_create(int size);
    - ```
